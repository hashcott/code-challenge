<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoreboard System Demo</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --accent-color: #ff6b35;
            --accent-light: #ff8c42;
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --card-bg: rgba(255, 255, 255, 0.05);
            --border-color: rgba(255, 255, 255, 0.1);
        }

        body {
            background: var(--primary-gradient);
            color: var(--text-primary);
            min-height: 100vh;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }
        
        /* Global custom scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-light));
            border-radius: 6px;
            border: 2px solid transparent;
            background-clip: content-box;
            transition: all 0.3s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--accent-light), #ff9f6b);
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
        }
        
        ::-webkit-scrollbar-corner {
            background: transparent;
        }

        .hero.is-primary {
            background: var(--primary-gradient);
            color: var(--text-primary);
        }

        .hero .title, .hero .subtitle {
            color: var(--text-primary);
        }

        .box {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        .box .title, .box .label {
            color: var(--text-primary);
        }

        .input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 0.125em rgba(255, 107, 53, 0.25);
        }

        .input::placeholder {
            color: var(--text-secondary);
        }

        .button.is-primary {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        .button.is-primary:hover {
            background: var(--accent-light);
            border-color: var(--accent-light);
        }

        .notification.is-success {
            background: rgba(46, 160, 67, 0.2);
            border: 1px solid rgba(46, 160, 67, 0.3);
            color: #4caf50;
            margin-bottom: 20px;
        }

        .notification.is-danger {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        .notification.is-warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
        }

        .status.connected {
            background: rgba(46, 160, 67, 0.2);
            color: #4caf50;
            border: 1px solid rgba(46, 160, 67, 0.3);
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .scoreboard {
            background: transparent;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: none;
            border: none;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }
        
        /* Custom scrollbar for scoreboard */
        .scoreboard::-webkit-scrollbar {
            width: 8px;
        }
        
        .scoreboard::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }
        
        .scoreboard::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .scoreboard::-webkit-scrollbar-thumb:hover {
            background: var(--accent-light);
            transform: scale(1.1);
        }

        .scoreboard-header {
            background: var(--accent-color);
            color: white;
            padding: 1rem;
            font-weight: 600;
            display: grid;
            grid-template-columns: 80px 1fr 120px;
            gap: 1rem;
            border-radius: 12px 12px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
            margin-bottom: 0.75rem;
        }

        .scoreboard-entry {
            padding: 1rem;
            border-bottom: none;
            display: grid;
            grid-template-columns: 80px 1fr 120px;
            gap: 1rem;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--text-primary);
            background: var(--card-bg);
            margin-bottom: 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .scoreboard-entry:hover {
            background: rgba(255, 107, 53, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.2);
        }

        /* Animation classes for scoreboard changes */
        .scoreboard-entry.rank-up {
            animation: rankUp 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), var(--card-bg));
            border-color: #4caf50;
        }

        .scoreboard-entry.rank-down {
            animation: rankDown 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.2), var(--card-bg));
            border-color: #f44336;
        }

        .scoreboard-entry.new-entry {
            animation: newEntry 1s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), var(--card-bg));
            border-color: var(--accent-color);
        }

        .scoreboard-entry.score-updated {
            animation: scoreUpdated 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Keyframe animations */
        @keyframes rankUp {
            0% {
                transform: translateY(20px) scale(0.95);
                opacity: 0.7;
            }
            50% {
                transform: translateY(-5px) scale(1.02);
                opacity: 1;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes rankDown {
            0% {
                transform: translateY(-20px) scale(0.95);
                opacity: 0.7;
            }
            50% {
                transform: translateY(5px) scale(1.02);
                opacity: 1;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes newEntry {
            0% {
                transform: translateX(-100%) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translateX(0) scale(1.05);
                opacity: 1;
            }
            100% {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes scoreUpdated {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
            }
            100% {
                transform: scale(1);
            }
        }

        .scoreboard-entry:last-child {
            margin-bottom: 0;
        }

        .rank {
            font-weight: 700;
            color: var(--accent-color);
            text-align: center;
            font-size: 1.1rem;
        }

        .username {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .score {
            text-align: right;
            font-weight: 700;
            color: #4caf50;
            font-size: 1.1rem;
        }

        /* Toast Message System */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px 20px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid #4caf50;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), var(--card-bg));
        }

        .toast.error {
            border-left: 4px solid #f44336;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), var(--card-bg));
        }

        .toast.warning {
            border-left: 4px solid #ffc107;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), var(--card-bg));
        }

        .toast.info {
            border-left: 4px solid var(--accent-color);
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.1), var(--card-bg));
        }

        .toast-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .toast-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .toast-message {
            color: var(--text-primary);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--accent-color);
            border-radius: 0 0 8px 8px;
            transition: width linear;
        }

        /* Mobile toast optimization */
        @media screen and (max-width: 768px) {
            .toast-container {
                top: 10px;
                right: 10px;
                left: 10px;
            }

            .toast {
                min-width: auto;
                max-width: none;
                width: 100%;
            }
        }

        .error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid rgba(244, 67, 54, 0.3);
            position: relative;
            animation: slideIn 0.3s ease-out;
        }

        .error-header {
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .error-details {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        .error-code {
            background: rgba(244, 67, 54, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            font-family: monospace;
        }

        .rate-limit-error {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .rate-limit-error .error-header {
            color: #ffc107;
        }

        .rate-limit-error .error-code {
            background: rgba(255, 193, 7, 0.2);
        }

        /* Bulma responsive optimizations */
        .section {
            padding: 1rem;
        }
        
        /* Section scrollbar styling */
        .section {
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }
        
        .section::-webkit-scrollbar {
            width: 8px;
        }
        
        .section::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .section::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .section::-webkit-scrollbar-thumb:hover {
            background: var(--accent-light);
        }
        
        /* Mobile padding optimization */
        @media screen and (max-width: 768px) {
            .section {
                padding: 0.5rem;
            }
            
            .box {
                padding: 0.75rem;
                margin-bottom: 0.75rem;
            }
            
            .hero-body {
                padding: 1rem 0.75rem;
            }
        }
        
        @media screen and (max-width: 480px) {
            .section {
                padding: 0.25rem;
            }
            
            .box {
                padding: 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .hero-body {
                padding: 0.75rem 0.5rem;
            }
            
            .container {
                padding: 0 0.5rem;
            }
        }
        
        /* Mobile scoreboard optimization */
        @media screen and (max-width: 768px) {
            .scoreboard-header,
            .scoreboard-entry {
                grid-template-columns: 60px 1fr 80px;
                gap: 0.75rem;
                padding: 0.75rem;
            }
            
            .scoreboard {
                max-height: 250px;
            }
            
            .scoreboard-header {
                position: sticky;
                top: 0;
                z-index: 10;
                margin-bottom: 0.5rem;
            }
        }
        
        @media screen and (max-width: 480px) {
            .scoreboard-header,
            .scoreboard-entry {
                grid-template-columns: 50px 1fr 70px;
                gap: 0.5rem;
                padding: 0.5rem;
            }
            
            .scoreboard {
                max-height: 200px;
            }
            
            .scoreboard-header {
                position: sticky;
                top: 0;
                z-index: 10;
                margin-bottom: 0.5rem;
            }
        }
        
        /* Desktop alignment for action section */
        @media screen and (min-width: 769px) {
            #actionSection .field.is-grouped-multiline .control:last-child {
                display: flex;
                align-items: end;
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <section class="hero is-primary is-small">
        <div class="hero-body">
            <div class="container">
                <h1 class="title is-2 is-size-3-mobile">üèÜ Scoreboard System</h1>
                <p class="subtitle is-4 is-size-6-mobile">Real-time scoreboard with WebSocket updates</p>
            </div>
        </div>
    </section>

    <section class="section py-2 py-4-mobile">
        <div class="container">
            <!-- Connection Status -->
            <div id="connectionStatus" class="status disconnected">
                WebSocket: Disconnected
            </div>

            <!-- Auth Section -->
            <div class="columns is-multiline">
                <div class="column is-half-tablet is-full-mobile">
                    <div class="box">
                        <h3 class="title is-4 is-size-5-mobile">üîê Register</h3>
                        <form id="registerForm">
                            <div class="field">
                                <label class="label" for="regUsername">Username</label>
                                <div class="control">
                                    <input class="input" type="text" id="regUsername" required>
                                </div>
                            </div>
                            <div class="field">
                                <label class="label" for="regEmail">Email</label>
                                <div class="control">
                                    <input class="input" type="email" id="regEmail" required>
                                </div>
                            </div>
                            <div class="field">
                                <label class="label" for="regPassword">Password</label>
                                <div class="control">
                                    <input class="input" type="password" id="regPassword" required>
                                </div>
                            </div>
                            <div class="field">
                                <div class="control">
                                    <button type="submit" class="button is-primary is-fullwidth">Register</button>
                                </div>
                            </div>
                        </form>
                    </div>
                </div>

                <div class="column is-half-tablet is-full-mobile">
                    <div class="box">
                        <h3 class="title is-4 is-size-5-mobile">üîë Login</h3>
                        <form id="loginForm">
                            <div class="field">
                                <label class="label" for="loginEmail">Email</label>
                                <div class="control">
                                    <input class="input" type="email" id="loginEmail" required>
                                </div>
                            </div>
                            <div class="field">
                                <label class="label" for="loginPassword">Password</label>
                                <div class="control">
                                    <input class="input" type="password" id="loginPassword" required>
                                </div>
                            </div>
                            <div class="field">
                                <div class="control">
                                    <button type="submit" class="button is-primary is-fullwidth">Login</button>
                                </div>
                            </div>
                        </form>
                    </div>
                </div>
            </div>

            <!-- User Info -->
            <div id="userInfo" class="is-hidden">
                <div class="notification is-success">
                    <div class="is-flex is-justify-content-space-between is-align-items-center">
                        <div>
                            <strong>Welcome, <span id="userName"></span>!</strong>
                        </div>
                        <button id="logoutBtn" class="button is-small">Logout</button>
                    </div>
                </div>
            </div>

            <!-- Scoreboard Section -->
            <div class="box">
                <h3 class="title is-4 is-size-5-mobile">üìä Live Scoreboard</h3>
                <div id="scoreboard" class="scoreboard">
                    <div class="has-text-centered has-text-grey">Loading scoreboard...</div>
                </div>
            </div>

            <!-- Action Section -->
            <div id="actionSection" class="box is-hidden">
                <h3 class="title is-4 is-size-5-mobile">üéØ Complete Action</h3>
                <div class="field">
                    <label class="label" for="scoreIncrement">Score Increment</label>
                    <div class="control">
                        <input class="input" type="number" id="scoreIncrement" value="50" min="1" max="1000">
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <button id="completeActionBtn" class="button is-primary is-fullwidth">Complete Action</button>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
        class ScoreboardApp {
            constructor() {
                this.ws = null;
                this.token = localStorage.getItem('token');
                this.user = JSON.parse(localStorage.getItem('user') || 'null');
                this.apiBase = window.location.origin;
                this.isMobile = window.innerWidth <= 768;
                
                this.initializeEventListeners();
                this.initializeWebSocket();
                this.loadScoreboard();
                this.setupMobileOptimizations();
                
                // Hide action section by default
                document.getElementById('actionSection').classList.add('is-hidden');
                
                // Validate session on startup
                if (this.user && this.user.username && this.token) {
                    this.showUserInfo();
                } else {
                    // Clear invalid session data without showing logout message
                    this.token = null;
                    this.user = null;
                    localStorage.removeItem('token');
                    localStorage.removeItem('user');
                    this.hideUserInfo();
                }
            }

            setupMobileOptimizations() {
                // Handle viewport changes
                window.addEventListener('resize', () => {
                    this.isMobile = window.innerWidth <= 768;
                    this.updateMobileLayout();
                });

                // Prevent zoom on input focus (iOS)
                const inputs = document.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('focus', () => {
                        if (this.isMobile) {
                            input.style.fontSize = '16px';
                        }
                    });
                });

                // Add touch-friendly interactions
                const buttons = document.querySelectorAll('.button');
                buttons.forEach(button => {
                    button.addEventListener('touchstart', (e) => {
                        e.target.style.transform = 'scale(0.98)';
                    });
                    button.addEventListener('touchend', (e) => {
                        e.target.style.transform = 'scale(1)';
                    });
                });
            }

            updateMobileLayout() {
                // Update scoreboard layout for mobile
                if (this.isMobile) {
                    const scoreboard = document.getElementById('scoreboard');
                    if (scoreboard) {
                        scoreboard.style.fontSize = '0.85rem';
                    }
                }
            }

            initializeEventListeners() {
                document.getElementById('registerForm').addEventListener('submit', (e) => this.handleRegister(e));
                document.getElementById('loginForm').addEventListener('submit', (e) => this.handleLogin(e));
                document.getElementById('logoutBtn').addEventListener('click', () => this.handleLogout());
                document.getElementById('completeActionBtn').addEventListener('click', () => this.handleCompleteAction());
            }

            async handleRegister(e) {
                e.preventDefault();
                const formData = new FormData(e.target);
                const data = {
                    username: formData.get('username') || document.getElementById('regUsername').value,
                    email: formData.get('email') || document.getElementById('regEmail').value,
                    password: formData.get('password') || document.getElementById('regPassword').value
                };

                try {
                    const response = await fetch(`${this.apiBase}/api/auth/register`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });

                    const result = await response.json();
                    
                    if (result.success) {
                        this.token = result.data.token;
                        this.user = result.data.user;
                        localStorage.setItem('token', this.token);
                        localStorage.setItem('user', JSON.stringify(this.user));
                        
                        // Clear form after successful registration
                        document.getElementById('registerForm').reset();
                        
                        this.showUserInfo();
                        this.showMessage('Registration successful!', 'success');
                        
                        // Reconnect WebSocket with new token
                        this.reconnectWebSocket();
                        
                        // Wait briefly for database transaction to complete, then load scoreboard
                        setTimeout(async () => {
                            await this.loadScoreboard();
                        }, 500);
                    } else {
                        this.showBackendError('Registration Failed', result.error, response.status);
                    }
                } catch (error) {
                    this.showNetworkError('Registration Failed', error);
                }
            }

            async handleLogin(e) {
                e.preventDefault();
                const data = {
                    email: document.getElementById('loginEmail').value,
                    password: document.getElementById('loginPassword').value
                };

                try {
                    const response = await fetch(`${this.apiBase}/api/auth/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });

                    const result = await response.json();
                    
                    if (result.success) {
                        this.token = result.data.token;
                        this.user = result.data.user;
                        localStorage.setItem('token', this.token);
                        localStorage.setItem('user', JSON.stringify(this.user));
                        
                        // Clear form after successful login
                        document.getElementById('loginForm').reset();
                        
                        this.showUserInfo();
                        this.showMessage('Login successful!', 'success');
                        
                        // Reconnect WebSocket with new token
                        this.reconnectWebSocket();
                    } else {
                        this.showBackendError('Login Failed', result.error, response.status);
                    }
                } catch (error) {
                    this.showNetworkError('Login Failed', error);
                }
            }

            handleLogout() {
                this.token = null;
                this.user = null;
                localStorage.removeItem('token');
                localStorage.removeItem('user');
                
                // Close WebSocket connection
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.hideUserInfo();
                this.showMessage('Logged out successfully', 'success');
            }

            showUserInfo() {
                document.getElementById('userInfo').classList.remove('is-hidden');
                document.getElementById('actionSection').classList.remove('is-hidden');
                // Hide auth forms when user is logged in
                document.querySelector('.columns').classList.add('is-hidden');
                const userNameEl = document.getElementById('userName');
                if (userNameEl && this.user) {
                    userNameEl.textContent = this.user.username;
                }
            }

            hideUserInfo() {
                document.getElementById('userInfo').classList.add('is-hidden');
                document.getElementById('actionSection').classList.add('is-hidden');
                // Show auth forms when user logs out
                document.querySelector('.columns').classList.remove('is-hidden');
            }

            async handleCompleteAction() {
                if (!this.validateSession()) {
                    return;
                }

                const scoreIncrement = parseInt(document.getElementById('scoreIncrement').value);
                
                try {
                    // Generate action data
                    const actionResponse = await fetch(`${this.apiBase}/api/scoreboard/generate-action`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.token}`
                        },
                        body: JSON.stringify({ scoreIncrement })
                    });

                    const actionResult = await actionResponse.json();
                    
                    if (!actionResult.success) {
                        // Check if token is invalid
                        if (actionResponse.status === 401) {
                            this.handleUnauthorized();
                            return;
                        }
                        this.showBackendError('Action Generation Failed', actionResult.error, actionResponse.status);
                        return;
                    }

                    // Update score
                    const updateResponse = await fetch(`${this.apiBase}/api/scoreboard/update`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.token}`
                        },
                        body: JSON.stringify(actionResult.data)
                    });

                    const updateResult = await updateResponse.json();
                    
                    if (updateResult.success) {
                        this.showMessage(`Score updated! New score: ${updateResult.data.newScore}`, 'success');
                    } else {
                        // Check if token is invalid
                        if (updateResponse.status === 401) {
                            this.handleUnauthorized();
                            return;
                        }
                        this.showBackendError('Score Update Failed', updateResult.error, updateResponse.status);
                    }
                } catch (error) {
                    this.showNetworkError('Action Failed', error);
                }
            }

            initializeWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.updateConnectionStatus(true);
                    console.log('WebSocket connected');
                };
                
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log('WebSocket message:', message);
                    
                    if (message.type === 'scoreboard_update') {
                        this.updateScoreboard(message.data.scoreboard);
                    }
                };
                
                this.ws.onclose = () => {
                    this.updateConnectionStatus(false);
                    console.log('WebSocket disconnected');
                    
                    // Only reconnect if user is still logged in
                    if (this.token && this.user) {
                        setTimeout(() => {
                            this.initializeWebSocket();
                        }, 3000);
                    }
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };
            }

            reconnectWebSocket() {
                // Close existing connection
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                // Reconnect with new token
                if (this.token && this.user) {
                    this.initializeWebSocket();
                }
            }

            updateConnectionStatus(connected) {
                const statusEl = document.getElementById('connectionStatus');
                if (connected) {
                    statusEl.className = 'status connected';
                    statusEl.textContent = 'WebSocket: Connected';
                } else {
                    statusEl.className = 'status disconnected';
                    statusEl.textContent = 'WebSocket: Disconnected';
                }
            }

            async loadScoreboard() {
                try {
                    const response = await fetch(`${this.apiBase}/api/scoreboard`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.updateScoreboard(result.data.scoreboard);
                    } else {
                        this.showBackendError('Scoreboard Load Failed', result.error, response.status);
                    }
                } catch (error) {
                    this.showNetworkError('Scoreboard Load Failed', error);
                }
            }

            // Validate token and user session
            validateSession() {
                if (!this.token || !this.user) {
                    this.handleLogout();
                    return false;
                }
                return true;
            }

            // Handle 401 Unauthorized errors
            handleUnauthorized() {
                this.showMessage('Session expired. Please login again.', 'error');
                this.handleLogout();
            }

            updateScoreboard(scoreboard) {
                const scoreboardEl = document.getElementById('scoreboard');
                
                if (!scoreboard || scoreboard.length === 0) {
                    scoreboardEl.innerHTML = '<div class="has-text-centered has-text-grey">No scores available</div>';
                    return;
                }

                // Always show top 10 users regardless of score
                const filteredScoreboard = scoreboard.slice(0, 10);

                // Store previous state for comparison
                const previousEntries = this.previousScoreboard || [];
                this.previousScoreboard = [...filteredScoreboard];

                const html = `
                    <div class="scoreboard-header">
                        <div>Rank</div>
                        <div>Username</div>
                        <div>Score</div>
                    </div>
                    ${filteredScoreboard.map(entry => `
                        <div class="scoreboard-entry" data-username="${entry.username}" data-rank="${entry.rank}" data-score="${entry.score}">
                            <div class="rank">#${entry.rank}</div>
                            <div class="username">${entry.username}</div>
                            <div class="score">${entry.score.toLocaleString()}</div>
                        </div>
                    `).join('')}
                `;
                
                scoreboardEl.innerHTML = html;

                // Add animations based on changes
                this.addScoreboardAnimations(filteredScoreboard, previousEntries);
            }

            addScoreboardAnimations(newScoreboard, previousScoreboard) {
                // Wait for DOM to be ready
                setTimeout(() => {
                    if (!previousScoreboard || previousScoreboard.length === 0) {
                        // First load - animate all entries as new
                        const entries = document.querySelectorAll('.scoreboard-entry');
                        entries.forEach((entry, index) => {
                            setTimeout(() => {
                                entry.classList.add('new-entry');
                                setTimeout(() => entry.classList.remove('new-entry'), 1000);
                            }, index * 100);
                        });
                        return;
                    }

                    // Create maps for easy lookup
                    const prevMap = new Map(previousScoreboard.map(entry => [entry.username, entry]));

                    // Animate each entry
                    newScoreboard.forEach((newEntry, index) => {
                        const entryEl = document.querySelector(`[data-username="${newEntry.username}"]`);
                        if (!entryEl) return;

                        const prevEntry = prevMap.get(newEntry.username);
                        
                        if (!prevEntry) {
                            // New entry
                            setTimeout(() => {
                                entryEl.classList.add('new-entry');
                                setTimeout(() => entryEl.classList.remove('new-entry'), 1000);
                            }, index * 50);
                        } else {
                            // Existing entry - check for changes
                            if (newEntry.rank < prevEntry.rank) {
                                // Rank improved
                                setTimeout(() => {
                                    entryEl.classList.add('rank-up');
                                    setTimeout(() => entryEl.classList.remove('rank-up'), 800);
                                }, index * 50);
                            } else if (newEntry.rank > prevEntry.rank) {
                                // Rank declined
                                setTimeout(() => {
                                    entryEl.classList.add('rank-down');
                                    setTimeout(() => entryEl.classList.remove('rank-down'), 800);
                                }, index * 50);
                            } else if (newEntry.score !== prevEntry.score) {
                                // Score updated but rank same
                                setTimeout(() => {
                                    entryEl.classList.add('score-updated');
                                    setTimeout(() => entryEl.classList.remove('score-updated'), 600);
                                }, index * 50);
                            }
                        }
                    });
                }, 100);
            }

            showMessage(message, type) {
                this.showToast(message, type);
            }

            showToast(message, type = 'info', duration = 5000) {
                const toastContainer = document.getElementById('toastContainer');
                const toastId = 'toast-' + Date.now();
                
                const toast = document.createElement('div');
                toast.id = toastId;
                toast.className = `toast ${type}`;
                
                const icon = this.getToastIcon(type);
                const title = this.getToastTitle(type);
                
                toast.innerHTML = `
                    <div class="toast-header">
                        <div class="toast-title">${icon} ${title}</div>
                        <button class="toast-close" onclick="this.closest('.toast').remove()">√ó</button>
                    </div>
                    <div class="toast-message">${message}</div>
                    <div class="toast-progress" style="width: 100%;"></div>
                `;
                
                toastContainer.appendChild(toast);
                
                // Trigger animation
                setTimeout(() => toast.classList.add('show'), 10);
                
                // Progress bar animation
                const progressBar = toast.querySelector('.toast-progress');
                progressBar.style.width = '0%';
                progressBar.style.transition = `width ${duration}ms linear`;
                
                // Auto remove
                const autoRemove = setTimeout(() => {
                    this.removeToast(toast);
                }, duration);
                
                // Manual close
                toast.querySelector('.toast-close').addEventListener('click', () => {
                    clearTimeout(autoRemove);
                    this.removeToast(toast);
                });
            }

            removeToast(toast) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }

            getToastIcon(type) {
                const icons = {
                    success: '‚úÖ',
                    error: '‚ùå',
                    warning: '‚ö†Ô∏è',
                    info: '‚ÑπÔ∏è'
                };
                return icons[type] || icons.info;
            }

            getToastTitle(type) {
                const titles = {
                    success: 'Success',
                    error: 'Error',
                    warning: 'Warning',
                    info: 'Info'
                };
                return titles[type] || titles.info;
            }

            showBackendError(title, error, statusCode) {
                // Extract message from error response
                let errorMessage = 'An unknown error occurred';
                let errorCode = '';
                let retryAfter = null;
                let toastType = 'error';
                
                // Handle different error structures
                if (typeof error === 'string') {
                    errorMessage = error;
                } else if (error && typeof error === 'object') {
                    // Handle nested error structure (error.error.message)
                    if (error.error && error.error.message) {
                        errorMessage = error.error.message;
                        errorCode = error.error.code || '';
                        retryAfter = error.error.retryAfter || error.retryAfter;
                    } else if (error.message) {
                        errorMessage = error.message;
                        errorCode = error.code || '';
                        retryAfter = error.retryAfter;
                    } else if (error.details) {
                        errorMessage = error.details;
                    }
                }
                
                // Determine toast type based on status code and error type
                if (statusCode === 429 || 
                    errorMessage.toLowerCase().includes('rate limit') ||
                    errorMessage.toLowerCase().includes('too many requests')) {
                    toastType = 'warning';
                    if (retryAfter) {
                        errorMessage = `Rate limit exceeded. Please try again in ${retryAfter} seconds.`;
                    } else {
                        errorMessage = 'Rate limit exceeded. Please wait a moment before trying again.';
                    }
                } else if (statusCode >= 500) {
                    toastType = 'error';
                } else if (statusCode >= 400) {
                    toastType = 'warning';
                }
                
                // Add error code to message if available
                if (errorCode) {
                    errorMessage = `${errorCode}: ${errorMessage}`;
                }
                
                // Show toast with extracted message
                this.showToast(errorMessage, toastType, 8000);
            }

            showNetworkError(title, error) {
                let errorMessage = 'Network connection failed';
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMessage = 'Unable to connect to server. Please check your internet connection.';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                this.showToast(`üåê ${title}: ${errorMessage}`, 'error', 8000);
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new ScoreboardApp();
        });
    </script>
</body>
</html>
